// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: products.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCategory = `-- name: CreateCategory :exec
insert into categories(created_at, name, image)
values(current_timestamp, $1, $2)
`

type CreateCategoryParams struct {
	Name  string `json:"name"`
	Image string `json:"image"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) error {
	_, err := q.db.Exec(ctx, createCategory, arg.Name, arg.Image)
	return err
}

const createOrder = `-- name: CreateOrder :exec
insert into orders(
        created_at,
        grand_total,
        serial_number,
        order_products_id,
        user_id
    )
values(
        current_timestamp,
        $1,
        $2,
        $3,
        $4
    )
`

type CreateOrderParams struct {
	GrandTotal      int32       `json:"grand_total"`
	SerialNumber    string      `json:"serial_number"`
	OrderProductsID int64       `json:"order_products_id"`
	UserID          pgtype.Int8 `json:"user_id"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) error {
	_, err := q.db.Exec(ctx, createOrder,
		arg.GrandTotal,
		arg.SerialNumber,
		arg.OrderProductsID,
		arg.UserID,
	)
	return err
}

const createOrderProduct = `-- name: CreateOrderProduct :exec
insert into order_products(
        created_at,
        quantity,
        total_price,
        product_variant,
        product_id,
        device_id
    )
values(
        current_timestamp,
        $1,
        $2,
        $3,
        $4,
        $5
    )
`

type CreateOrderProductParams struct {
	Quantity       int32       `json:"quantity"`
	TotalPrice     int32       `json:"total_price"`
	ProductVariant pgtype.Int8 `json:"product_variant"`
	ProductID      int64       `json:"product_id"`
	DeviceID       string      `json:"device_id"`
}

func (q *Queries) CreateOrderProduct(ctx context.Context, arg CreateOrderProductParams) error {
	_, err := q.db.Exec(ctx, createOrderProduct,
		arg.Quantity,
		arg.TotalPrice,
		arg.ProductVariant,
		arg.ProductID,
		arg.DeviceID,
	)
	return err
}

const createProduct = `-- name: CreateProduct :exec
insert into products(
        created_at,
        name,
        price,
        discount_price,
        sku,
        description,
        stock_count,
        category_id,
        default_image
    )
values(
        current_timestamp,
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    )
`

type CreateProductParams struct {
	Name          string      `json:"name"`
	Price         int32       `json:"price"`
	DiscountPrice pgtype.Int4 `json:"discount_price"`
	Sku           string      `json:"sku"`
	Description   string      `json:"description"`
	StockCount    int32       `json:"stock_count"`
	CategoryID    int64       `json:"category_id"`
	DefaultImage  string      `json:"default_image"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) error {
	_, err := q.db.Exec(ctx, createProduct,
		arg.Name,
		arg.Price,
		arg.DiscountPrice,
		arg.Sku,
		arg.Description,
		arg.StockCount,
		arg.CategoryID,
		arg.DefaultImage,
	)
	return err
}

const createProductSpec = `-- name: CreateProductSpec :exec
insert into product_specifications(
        created_at,
        name,
        description,
        product_id
    )
values(
        current_timestamp,
        $1,
        $2,
        $3
    )
`

type CreateProductSpecParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ProductID   int64  `json:"product_id"`
}

func (q *Queries) CreateProductSpec(ctx context.Context, arg CreateProductSpecParams) error {
	_, err := q.db.Exec(ctx, createProductSpec, arg.Name, arg.Description, arg.ProductID)
	return err
}

const createVariant = `-- name: CreateVariant :exec
insert into product_variants(created_at, name, product_id, type)
values(
        current_timestamp,
        $1,
        $2,
        $3
    )
`

type CreateVariantParams struct {
	Name      string `json:"name"`
	ProductID int64  `json:"product_id"`
	Type      int32  `json:"type"`
}

func (q *Queries) CreateVariant(ctx context.Context, arg CreateVariantParams) error {
	_, err := q.db.Exec(ctx, createVariant, arg.Name, arg.ProductID, arg.Type)
	return err
}

const createWishlist = `-- name: CreateWishlist :exec
insert into wishlists(created_at, product_id, user_id)
values(
        current_timestamp,
        $1,
        $2
    )
`

type CreateWishlistParams struct {
	ProductID int64 `json:"product_id"`
	UserID    int64 `json:"user_id"`
}

func (q *Queries) CreateWishlist(ctx context.Context, arg CreateWishlistParams) error {
	_, err := q.db.Exec(ctx, createWishlist, arg.ProductID, arg.UserID)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
delete from categories
where id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deleteOrder = `-- name: DeleteOrder :exec
delete from orders
where order_products_id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, orderProductsID int64) error {
	_, err := q.db.Exec(ctx, deleteOrder, orderProductsID)
	return err
}

const deleteOrderProduct = `-- name: DeleteOrderProduct :exec
delete from order_products
where id = $1
`

func (q *Queries) DeleteOrderProduct(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteOrderProduct, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
delete from products
where id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteProductSpec = `-- name: DeleteProductSpec :exec
delete from product_specifications
where id = $1
`

func (q *Queries) DeleteProductSpec(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProductSpec, id)
	return err
}

const deleteVariant = `-- name: DeleteVariant :exec
delete from product_variants
where id = $1
`

func (q *Queries) DeleteVariant(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteVariant, id)
	return err
}

const deleteWishlist = `-- name: DeleteWishlist :exec
delete from wishlists
where id = $1
`

func (q *Queries) DeleteWishlist(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteWishlist, id)
	return err
}

const getCategory = `-- name: GetCategory :one
select id, created_at, updated_at, deleted_at, name, image
from categories
where id = $1
`

func (q *Queries) GetCategory(ctx context.Context, id int64) (*Categories, error) {
	row := q.db.QueryRow(ctx, getCategory, id)
	var i Categories
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Image,
	)
	return &i, err
}

const getOrderProduct = `-- name: GetOrderProduct :one
select p.id,
    p.created_at,
    p.updated_at,
    p.name,
    p.price,
    p.discount_price,
    p.sku,
    p.description,
    p.stock_count,
    p.category_id,
    p.default_image,
    pv.id,
    pv.name,
    order_products.id,
    order_products.total_price,
    order_products.device_id,
    order_products.quantity
from order_products
    left join product_variants pv on pv.id = order_products.product_variant
    left join products p on p.id = order_products.product_id
where order_products.id = $1
`

type GetOrderProductRow struct {
	ID            pgtype.Int8        `json:"id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Name          pgtype.Text        `json:"name"`
	Price         pgtype.Int4        `json:"price"`
	DiscountPrice pgtype.Int4        `json:"discount_price"`
	Sku           pgtype.Text        `json:"sku"`
	Description   pgtype.Text        `json:"description"`
	StockCount    pgtype.Int4        `json:"stock_count"`
	CategoryID    pgtype.Int8        `json:"category_id"`
	DefaultImage  pgtype.Text        `json:"default_image"`
	ID_2          pgtype.Int8        `json:"id_2"`
	Name_2        pgtype.Text        `json:"name_2"`
	ID_3          int64              `json:"id_3"`
	TotalPrice    int32              `json:"total_price"`
	DeviceID      string             `json:"device_id"`
	Quantity      int32              `json:"quantity"`
}

func (q *Queries) GetOrderProduct(ctx context.Context, id int64) (*GetOrderProductRow, error) {
	row := q.db.QueryRow(ctx, getOrderProduct, id)
	var i GetOrderProductRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Price,
		&i.DiscountPrice,
		&i.Sku,
		&i.Description,
		&i.StockCount,
		&i.CategoryID,
		&i.DefaultImage,
		&i.ID_2,
		&i.Name_2,
		&i.ID_3,
		&i.TotalPrice,
		&i.DeviceID,
		&i.Quantity,
	)
	return &i, err
}

const getVariant = `-- name: GetVariant :one
select id, created_at, updated_at, deleted_at, type, name, product_id
from product_variants
where id = $1
`

func (q *Queries) GetVariant(ctx context.Context, id int64) (*ProductVariants, error) {
	row := q.db.QueryRow(ctx, getVariant, id)
	var i ProductVariants
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Type,
		&i.Name,
		&i.ProductID,
	)
	return &i, err
}

const getWishlist = `-- name: GetWishlist :one
select id, created_at, updated_at, deleted_at, product_id, user_id
from wishlists
where user_id = $1
    and product_id = $2
`

type GetWishlistParams struct {
	UserID    int64 `json:"user_id"`
	ProductID int64 `json:"product_id"`
}

func (q *Queries) GetWishlist(ctx context.Context, arg GetWishlistParams) (*Wishlists, error) {
	row := q.db.QueryRow(ctx, getWishlist, arg.UserID, arg.ProductID)
	var i Wishlists
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProductID,
		&i.UserID,
	)
	return &i, err
}

const listCategories = `-- name: ListCategories :many
select id, created_at, updated_at, deleted_at, name, image
from categories
`

func (q *Queries) ListCategories(ctx context.Context) ([]*Categories, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Categories{}
	for rows.Next() {
		var i Categories
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderProducts = `-- name: ListOrderProducts :many
select p.id,
    p.created_at,
    p.updated_at,
    p.name,
    p.price,
    p.discount_price,
    p.sku,
    p.description,
    p.stock_count,
    p.category_id,
    p.default_image,
    pv.id,
    pv.name,
    order_products.id,
    order_products.device_id,
    order_products.total_price,
    order_products.quantity
from order_products
    left join product_variants pv on pv.id = order_products.product_variant
    left join products p on p.id = order_products.product_id
`

type ListOrderProductsRow struct {
	ID            pgtype.Int8        `json:"id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Name          pgtype.Text        `json:"name"`
	Price         pgtype.Int4        `json:"price"`
	DiscountPrice pgtype.Int4        `json:"discount_price"`
	Sku           pgtype.Text        `json:"sku"`
	Description   pgtype.Text        `json:"description"`
	StockCount    pgtype.Int4        `json:"stock_count"`
	CategoryID    pgtype.Int8        `json:"category_id"`
	DefaultImage  pgtype.Text        `json:"default_image"`
	ID_2          pgtype.Int8        `json:"id_2"`
	Name_2        pgtype.Text        `json:"name_2"`
	ID_3          int64              `json:"id_3"`
	DeviceID      string             `json:"device_id"`
	TotalPrice    int32              `json:"total_price"`
	Quantity      int32              `json:"quantity"`
}

func (q *Queries) ListOrderProducts(ctx context.Context) ([]*ListOrderProductsRow, error) {
	rows, err := q.db.Query(ctx, listOrderProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListOrderProductsRow{}
	for rows.Next() {
		var i ListOrderProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Price,
			&i.DiscountPrice,
			&i.Sku,
			&i.Description,
			&i.StockCount,
			&i.CategoryID,
			&i.DefaultImage,
			&i.ID_2,
			&i.Name_2,
			&i.ID_3,
			&i.DeviceID,
			&i.TotalPrice,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
select orders.created_at,
    orders.grand_total,
    orders.serial_number,
    orders.order_products_id,
    op.quantity,
    op.total_price,
    op.device_id,
    op.product_variant,
    p.id,
    p.name,
    p.price,
    p.discount_price,
    p.sku,
    p.default_image,
    u.id,
    u.email,
    u.phone_number
from orders
    left join order_products op on op.id = orders.order_products_id
    left join products p on p.id = op.product_id
    left join users u on u.id = orders.user_id
`

type ListOrdersRow struct {
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	GrandTotal      int32              `json:"grand_total"`
	SerialNumber    string             `json:"serial_number"`
	OrderProductsID int64              `json:"order_products_id"`
	Quantity        pgtype.Int4        `json:"quantity"`
	TotalPrice      pgtype.Int4        `json:"total_price"`
	DeviceID        pgtype.Text        `json:"device_id"`
	ProductVariant  pgtype.Int8        `json:"product_variant"`
	ID              pgtype.Int8        `json:"id"`
	Name            pgtype.Text        `json:"name"`
	Price           pgtype.Int4        `json:"price"`
	DiscountPrice   pgtype.Int4        `json:"discount_price"`
	Sku             pgtype.Text        `json:"sku"`
	DefaultImage    pgtype.Text        `json:"default_image"`
	ID_2            pgtype.Int8        `json:"id_2"`
	Email           pgtype.Text        `json:"email"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
}

func (q *Queries) ListOrders(ctx context.Context) ([]*ListOrdersRow, error) {
	rows, err := q.db.Query(ctx, listOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListOrdersRow{}
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.GrandTotal,
			&i.SerialNumber,
			&i.OrderProductsID,
			&i.Quantity,
			&i.TotalPrice,
			&i.DeviceID,
			&i.ProductVariant,
			&i.ID,
			&i.Name,
			&i.Price,
			&i.DiscountPrice,
			&i.Sku,
			&i.DefaultImage,
			&i.ID_2,
			&i.Email,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
select products.id, products.created_at, products.updated_at, products.deleted_at, average_rating, products.name, price, discount_price, sku, description, stock_count, min_stock_count, category_id, total_ratings, total_view, default_image, c.id, c.created_at, c.updated_at, c.deleted_at, c.name, image
from products
    left join categories c on c.id = products.id
`

type ListProductsRow struct {
	ID            int64              `json:"id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
	AverageRating pgtype.Int4        `json:"average_rating"`
	Name          string             `json:"name"`
	Price         int32              `json:"price"`
	DiscountPrice pgtype.Int4        `json:"discount_price"`
	Sku           string             `json:"sku"`
	Description   string             `json:"description"`
	StockCount    int32              `json:"stock_count"`
	MinStockCount int32              `json:"min_stock_count"`
	CategoryID    int64              `json:"category_id"`
	TotalRatings  int32              `json:"total_ratings"`
	TotalView     pgtype.Int4        `json:"total_view"`
	DefaultImage  string             `json:"default_image"`
	ID_2          pgtype.Int8        `json:"id_2"`
	CreatedAt_2   pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2   pgtype.Timestamptz `json:"updated_at_2"`
	DeletedAt_2   pgtype.Timestamptz `json:"deleted_at_2"`
	Name_2        pgtype.Text        `json:"name_2"`
	Image         pgtype.Text        `json:"image"`
}

func (q *Queries) ListProducts(ctx context.Context) ([]*ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProductsRow{}
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.AverageRating,
			&i.Name,
			&i.Price,
			&i.DiscountPrice,
			&i.Sku,
			&i.Description,
			&i.StockCount,
			&i.MinStockCount,
			&i.CategoryID,
			&i.TotalRatings,
			&i.TotalView,
			&i.DefaultImage,
			&i.ID_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.Name_2,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOrders = `-- name: ListUserOrders :many
select orders.created_at,
    orders.grand_total,
    orders.serial_number,
    orders.order_products_id,
    op.quantity,
    op.total_price,
    op.device_id,
    op.product_variant,
    p.id,
    p.name,
    p.price,
    p.discount_price,
    p.sku,
    p.default_image,
    u.id,
    u.email,
    u.phone_number
from orders
    left join order_products op on op.id = orders.order_products_id
    left join products p on p.id = op.product_id
    left join users u on u.id = orders.user_id
where orders.user_id = $1
`

type ListUserOrdersRow struct {
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	GrandTotal      int32              `json:"grand_total"`
	SerialNumber    string             `json:"serial_number"`
	OrderProductsID int64              `json:"order_products_id"`
	Quantity        pgtype.Int4        `json:"quantity"`
	TotalPrice      pgtype.Int4        `json:"total_price"`
	DeviceID        pgtype.Text        `json:"device_id"`
	ProductVariant  pgtype.Int8        `json:"product_variant"`
	ID              pgtype.Int8        `json:"id"`
	Name            pgtype.Text        `json:"name"`
	Price           pgtype.Int4        `json:"price"`
	DiscountPrice   pgtype.Int4        `json:"discount_price"`
	Sku             pgtype.Text        `json:"sku"`
	DefaultImage    pgtype.Text        `json:"default_image"`
	ID_2            pgtype.Int8        `json:"id_2"`
	Email           pgtype.Text        `json:"email"`
	PhoneNumber     pgtype.Text        `json:"phone_number"`
}

func (q *Queries) ListUserOrders(ctx context.Context, userID pgtype.Int8) ([]*ListUserOrdersRow, error) {
	rows, err := q.db.Query(ctx, listUserOrders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListUserOrdersRow{}
	for rows.Next() {
		var i ListUserOrdersRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.GrandTotal,
			&i.SerialNumber,
			&i.OrderProductsID,
			&i.Quantity,
			&i.TotalPrice,
			&i.DeviceID,
			&i.ProductVariant,
			&i.ID,
			&i.Name,
			&i.Price,
			&i.DiscountPrice,
			&i.Sku,
			&i.DefaultImage,
			&i.ID_2,
			&i.Email,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVariants = `-- name: ListVariants :many
select id, created_at, updated_at, deleted_at, type, name, product_id
from product_variants
where product_id = $1
`

func (q *Queries) ListVariants(ctx context.Context, productID int64) ([]*ProductVariants, error) {
	rows, err := q.db.Query(ctx, listVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProductVariants{}
	for rows.Next() {
		var i ProductVariants
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Type,
			&i.Name,
			&i.ProductID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWishlist = `-- name: ListWishlist :many
select wishlists.id, wishlists.created_at, wishlists.updated_at, wishlists.deleted_at, product_id, user_id, p.id, p.created_at, p.updated_at, p.deleted_at, average_rating, name, price, discount_price, sku, description, stock_count, min_stock_count, category_id, total_ratings, total_view, default_image
from wishlists
    left join products p on p.id = product_id
where user_id = $1
`

type ListWishlistRow struct {
	ID            int64              `json:"id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
	ProductID     int64              `json:"product_id"`
	UserID        int64              `json:"user_id"`
	ID_2          pgtype.Int8        `json:"id_2"`
	CreatedAt_2   pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2   pgtype.Timestamptz `json:"updated_at_2"`
	DeletedAt_2   pgtype.Timestamptz `json:"deleted_at_2"`
	AverageRating pgtype.Int4        `json:"average_rating"`
	Name          pgtype.Text        `json:"name"`
	Price         pgtype.Int4        `json:"price"`
	DiscountPrice pgtype.Int4        `json:"discount_price"`
	Sku           pgtype.Text        `json:"sku"`
	Description   pgtype.Text        `json:"description"`
	StockCount    pgtype.Int4        `json:"stock_count"`
	MinStockCount pgtype.Int4        `json:"min_stock_count"`
	CategoryID    pgtype.Int8        `json:"category_id"`
	TotalRatings  pgtype.Int4        `json:"total_ratings"`
	TotalView     pgtype.Int4        `json:"total_view"`
	DefaultImage  pgtype.Text        `json:"default_image"`
}

func (q *Queries) ListWishlist(ctx context.Context, userID int64) ([]*ListWishlistRow, error) {
	rows, err := q.db.Query(ctx, listWishlist, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWishlistRow{}
	for rows.Next() {
		var i ListWishlistRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProductID,
			&i.UserID,
			&i.ID_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.AverageRating,
			&i.Name,
			&i.Price,
			&i.DiscountPrice,
			&i.Sku,
			&i.Description,
			&i.StockCount,
			&i.MinStockCount,
			&i.CategoryID,
			&i.TotalRatings,
			&i.TotalView,
			&i.DefaultImage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const oneProduct = `-- name: OneProduct :one
SELECT products.id,
    products.created_at,
    products.updated_at,
    products.name,
    products.price,
    products.discount_price,
    products.sku,
    products.description,
    products.stock_count,
    products.category_id,
    products.default_image,
    products.average_rating,
    products.total_ratings,
    products.total_view,
    products.min_stock_count,
    COALESCE(
        (
            SELECT JSON_AGG(
                    JSON_BUILD_OBJECT(
                        'id',
                        ps.id,
                        'name',
                        ps.name,
                        'description',
                        ps.description
                    )
                )
            FROM product_specifications ps
            WHERE ps.product_id = products.id
        ),
        '[]'::JSON
    ) AS product_specifications,
    COALESCE(
        (
            SELECT JSON_AGG(
                    JSON_BUILD_OBJECT(
                        'id',
                        pr.id,
                        'name',
                        pr.name,
                        'type',
                        pr.type
                    )
                )
            FROM product_variants pr
            WHERE pr.product_id = products.id
        ),
        '[]'::JSON
    ) AS product_variants
FROM products
WHERE products.id = $1
`

type OneProductRow struct {
	ID                    int64              `json:"id"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	Name                  string             `json:"name"`
	Price                 int32              `json:"price"`
	DiscountPrice         pgtype.Int4        `json:"discount_price"`
	Sku                   string             `json:"sku"`
	Description           string             `json:"description"`
	StockCount            int32              `json:"stock_count"`
	CategoryID            int64              `json:"category_id"`
	DefaultImage          string             `json:"default_image"`
	AverageRating         pgtype.Int4        `json:"average_rating"`
	TotalRatings          int32              `json:"total_ratings"`
	TotalView             pgtype.Int4        `json:"total_view"`
	MinStockCount         int32              `json:"min_stock_count"`
	ProductSpecifications interface{}        `json:"product_specifications"`
	ProductVariants       interface{}        `json:"product_variants"`
}

func (q *Queries) OneProduct(ctx context.Context, id int64) (*OneProductRow, error) {
	row := q.db.QueryRow(ctx, oneProduct, id)
	var i OneProductRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Price,
		&i.DiscountPrice,
		&i.Sku,
		&i.Description,
		&i.StockCount,
		&i.CategoryID,
		&i.DefaultImage,
		&i.AverageRating,
		&i.TotalRatings,
		&i.TotalView,
		&i.MinStockCount,
		&i.ProductSpecifications,
		&i.ProductVariants,
	)
	return &i, err
}

const productSpecifications = `-- name: ProductSpecifications :many
select id, created_at, updated_at, deleted_at, name, description, product_id
from product_specifications
where product_id = $1
`

func (q *Queries) ProductSpecifications(ctx context.Context, productID int64) ([]*ProductSpecifications, error) {
	rows, err := q.db.Query(ctx, productSpecifications, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProductSpecifications{}
	for rows.Next() {
		var i ProductSpecifications
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Description,
			&i.ProductID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productsByCategory = `-- name: ProductsByCategory :many
select id, created_at, updated_at, deleted_at, average_rating, name, price, discount_price, sku, description, stock_count, min_stock_count, category_id, total_ratings, total_view, default_image
from products
where category_id = $1
    and products.id > $2
order by products.created_at desc
limit 50
`

type ProductsByCategoryParams struct {
	CategoryID int64 `json:"category_id"`
	ID         int64 `json:"id"`
}

func (q *Queries) ProductsByCategory(ctx context.Context, arg ProductsByCategoryParams) ([]*Products, error) {
	rows, err := q.db.Query(ctx, productsByCategory, arg.CategoryID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Products{}
	for rows.Next() {
		var i Products
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.AverageRating,
			&i.Name,
			&i.Price,
			&i.DiscountPrice,
			&i.Sku,
			&i.Description,
			&i.StockCount,
			&i.MinStockCount,
			&i.CategoryID,
			&i.TotalRatings,
			&i.TotalView,
			&i.DefaultImage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCategory = `-- name: UpdateCategory :exec
update categories
set updated_at = current_timestamp,
    name = $2,
    image = $3
where id = $1
`

type UpdateCategoryParams struct {
	ID    int64  `json:"id"`
	Name  string `json:"name"`
	Image string `json:"image"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.Exec(ctx, updateCategory, arg.ID, arg.Name, arg.Image)
	return err
}

const updateOrder = `-- name: UpdateOrder :exec
update orders
set updated_at = current_timestamp,
    grand_total = $2
where order_products_id = $1
`

type UpdateOrderParams struct {
	OrderProductsID int64 `json:"order_products_id"`
	GrandTotal      int32 `json:"grand_total"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) error {
	_, err := q.db.Exec(ctx, updateOrder, arg.OrderProductsID, arg.GrandTotal)
	return err
}

const updateOrderProduct = `-- name: UpdateOrderProduct :exec
update order_products
set updated_at = current_timestamp,
    quantity = $2,
    total_price = $3,
    product_variant = $4
where id = $1
`

type UpdateOrderProductParams struct {
	ID             int64       `json:"id"`
	Quantity       int32       `json:"quantity"`
	TotalPrice     int32       `json:"total_price"`
	ProductVariant pgtype.Int8 `json:"product_variant"`
}

func (q *Queries) UpdateOrderProduct(ctx context.Context, arg UpdateOrderProductParams) error {
	_, err := q.db.Exec(ctx, updateOrderProduct,
		arg.ID,
		arg.Quantity,
		arg.TotalPrice,
		arg.ProductVariant,
	)
	return err
}

const updateProduct = `-- name: UpdateProduct :exec
update products
set updated_at = current_timestamp,
    name = $2,
    price = $3,
    discount_price = $4,
    sku = $5,
    description = $6,
    stock_count = $7,
    category_id = $8,
    default_image = $9
where id = $1
`

type UpdateProductParams struct {
	ID            int64       `json:"id"`
	Name          string      `json:"name"`
	Price         int32       `json:"price"`
	DiscountPrice pgtype.Int4 `json:"discount_price"`
	Sku           string      `json:"sku"`
	Description   string      `json:"description"`
	StockCount    int32       `json:"stock_count"`
	CategoryID    int64       `json:"category_id"`
	DefaultImage  string      `json:"default_image"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Price,
		arg.DiscountPrice,
		arg.Sku,
		arg.Description,
		arg.StockCount,
		arg.CategoryID,
		arg.DefaultImage,
	)
	return err
}

const updateProductSpec = `-- name: UpdateProductSpec :exec
update product_specifications
set updated_at = current_timestamp,
    name = $2,
    description = $3,
    product_id = $4
where id = $1
`

type UpdateProductSpecParams struct {
	ID          int64  `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	ProductID   int64  `json:"product_id"`
}

func (q *Queries) UpdateProductSpec(ctx context.Context, arg UpdateProductSpecParams) error {
	_, err := q.db.Exec(ctx, updateProductSpec,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ProductID,
	)
	return err
}

const updateVariant = `-- name: UpdateVariant :exec
update product_variants
set updated_at = current_timestamp,
    name = $2,
    product_id = $3,
    type = $4
where id = $1
`

type UpdateVariantParams struct {
	ID        int64  `json:"id"`
	Name      string `json:"name"`
	ProductID int64  `json:"product_id"`
	Type      int32  `json:"type"`
}

func (q *Queries) UpdateVariant(ctx context.Context, arg UpdateVariantParams) error {
	_, err := q.db.Exec(ctx, updateVariant,
		arg.ID,
		arg.Name,
		arg.ProductID,
		arg.Type,
	)
	return err
}
